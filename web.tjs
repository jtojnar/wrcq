"use strict";

var express = require('express');
var path = require('path');
var fs = require('fs');
var url = require('url');

var parseString = require('xml2js').parseString;

var passport = require('passport');
var LocalStrategy = require('passport-local').Strategy;
var crypto = require('crypto');
var sha1 = function(d) {
	return crypto.createHash('sha1').update(d).digest('hex');
};

function increment(obj, alpha, beta) {
	if(!obj.hasOwnProperty(alpha)) {
		obj[alpha] = {};
	}
	if(!obj[alpha].hasOwnProperty(beta)) {
		obj[alpha][beta] = 0;
	}
	return ++obj[alpha][beta];
}

var _dbUri = process.env.DATABASE_URL;

passport.serializeUser(function(user, done) {
	done(null, user.id);
});
passport.deserializeUser(function(id, done) {
	pg.connect(_dbUri, function(err, client, pgdone) {
		if(err) {
			pgdone();
			return done(err, false);
		}

		await client.query('select * from "user" where "id"=$1', [id], defer(row, result));
		pgdone();
		if(result.rowCount == 0) {
			return done(err, false);
		}
		var user = result.rows[0];
		return done(err, user);
	});
});


// thisisdangerous
passport.use(new LocalStrategy(
	function(email, password, done) {
		process.nextTick(function () {
			pg.connect(_dbUri, function(err, client, pgdone) {
				if(err) {
					pgdone();
					return done(err);
				}

				await client.query('select * from "user" where "email"=$1', [email], defer(row, result));
				pgdone();
				if(result.rowCount == 0) {
					return done(null, false, {message: 'Unknown user ' + email});
				}
				var user = result.rows[0];
				if(user.password != sha1(password+user.salt)) {
					return done(null, false, {message: 'Invalid password'});
				}
				return done(null, user);
			});
		});
	}
));

var hbs = require('express-handlebars');

var helpers = require('./helpers');

var pg = require('pg');

var publicDir = path.join(__dirname, 'public');

var app = express();

var allowCrossDomain = function(req, res, next) {
	res.header('Access-Control-Allow-Origin', '*');

	next();
}

app.set('views', path.join(__dirname, 'view'));
app.set('port', process.env.PORT || 5000);
var serveStatic = require('serve-static');
app.engine('hbs', hbs({defaultLayout: 'layout', extname: '.hbs', layoutsDir: 'view', partialsDir: path.join(__dirname, 'view', 'partial'), helpers: helpers}));
app.set('view engine', 'hbs');

app.use(require('cookie-parser')());

var bodyParser = require('body-parser');
app.use(bodyParser.urlencoded({extended: true}));
app.use(bodyParser.json());

var multipart = require('connect-multiparty');

app.use(require('method-override')());
app.use(require('express-session')({secret: 'too much to bear', resave: true, saveUninitialized: true}));
app.use(require('express-flash')());
app.use(passport.initialize());
app.use(passport.session());

app.use(require('serve-favicon')(__dirname + '/public/favicon.ico'));
app.use(allowCrossDomain);
app.use(serveStatic(publicDir));
app.use('/bower_components', serveStatic(path.join(__dirname, 'bower_components')));

var env = process.env.NODE_ENV || 'development';
if(env == 'development') {
	app.use(require('morgan')('common'));
}


function addEventLinks(links, row) {
	row.links = [];
	for(var i = 0; i < links.length; i++) {
		if(links[i].event_id == row.id) {
			row.links.push(links[i]);
		}
	};
}

app.post('/api/update/add', function(req, res) {
	if(!req.user) {
		return res.status(403).send('User not logged in.').end();
	}
	if(!req.body.content || req.body.content.trim() === '') {
		return res.status(400).send('Empty update text.').end();
	}
	pg.connect(_dbUri, function(err, client, done) {
		await client.query('insert into update(text, user_id, timestamp) values($1, $2, $3) returning id', [req.body.content, req.user.id, new Date()], defer(var err, data));
		done();
		if(!err) {
			return res.status(200).send(data.rows[0].id.toString()).end();
		} else {
			console.error(err);
			return res.status(500).end();
		}
	});
});

app.post('/api/update/edit', function(req, res) {
	if(!req.user) {
		return res.status(403).send('User not logged in.').end();
	}
	if(!req.body.id || isNaN(parseInt(req.body.id))) {
		return res.status(400).send('Invalid or mising id.').end();
	}
	var id = parseInt(req.body.id);

	if(!req.body.content || req.body.content.trim() === '') {
		return res.status(400).send('Empty update text.').end();
	}
	pg.connect(_dbUri, function(err, client, done) {
		await client.query('update update set text = $1 where id = $2', [req.body.content, req.body.id], defer(var err));
		done();
		if(!err) {
			return res.status(200).end();
		} else {
			console.error(err);
			return res.status(500).end();
		}
	});
});

var updatesRoute = require('./route/updates');
updatesRoute.inject(pg, _dbUri);

app.get('/', function(req, res) {
	pg.connect(_dbUri, function(err, client, done) {
		await client.query('select * from update order by timestamp desc limit 5', defer(var row, updates));
		await client.query('select * from link', defer(var row, links));
		links = links.rows;
		var eventsQuery = client.query('select * from event left join (select event_id from team group by event_id) as team on team.event_id = event.id where level=\'world\' order by start asc', function() {});
		eventsQuery.on('row', function(row) {addEventLinks(links, row);});
		await eventsQuery.on('end', defer(var events));
		done();
		res.render('index', {updates: updates.rows, events: events.rows, identity: req.user, last: true});
	});
});

app.get('/archive', updatesRoute.archive);

var eventsRoute = require('./route/events');
eventsRoute.inject(pg, fs, _dbUri);

app.get('/events', function(req, res) {
	pg.connect(_dbUri, function(err, client, done) {
		await client.query('select * from link', defer(var row, links));
		links = links.rows;
		var eventsQuery = client.query('with latest as (select *, row_number() over(partition by level order by start desc) as rk from event) select * from latest left join (select event_id from team group by event_id) as team on team.event_id = latest.id where rk <= 2 order by level=\'world\' desc, level::text like \'regional%\' desc, level::text like \'national%\' desc, start desc', function() {});
		eventsQuery.on('row', function(row) {addEventLinks(links, row);});
		await eventsQuery.on('end', defer(var events));
		var pastEventsQuery = client.query('with latest as (select *, row_number() over(partition by level order by start desc) as rk from event) select * from latest left join (select event_id from team group by event_id) as team on team.event_id = latest.id where rk > 2 order by level=\'world\' desc, level::text like \'regional%\' desc, level::text like \'national%\' desc, start desc', function() {});
		pastEventsQuery.on('row', function(row) {addEventLinks(links, row);});
		await pastEventsQuery.on('end', defer(var pastEvents));
		done();
		res.render('events', {events: {events: events.rows}, pastEvents: {events: pastEvents.rows}, identity: req.user});
	});
});

app.get('/events/add', eventsRoute.add);
app.post('/events/add', eventsRoute.add);

app.get('/events/:event/upload', eventsRoute.upload);
app.post('/events/:event/upload', multipart(), eventsRoute.upload);

function pushQualified(qualified, type, criterion, criterion_qualified, eventIds) {
	for(member in criterion_qualified.rows) {
		if(criterion_qualified.rows.hasOwnProperty(member)) {
			var member = criterion_qualified.rows[member];
			if(!qualified[type].hasOwnProperty(member.country_code)) {
				qualified[type][member.country_code] = {};
			}
			if(!qualified[type][member.country_code].hasOwnProperty(member.person_id)) {
				qualified[type][member.country_code][member.person_id] = {firstname: member.firstname, lastname: member.lastname, country_code: member.country_code, reasons: []};
			}
			if(criterion === '1.1' || criterion == '1.3') {
				var reason = {
					criterion: criterion,
					event: eventIds[member.event_id].slug,
					gender: member.gender,
					position: member.position,
					age: 'open'
				};
				qualified[type][member.country_code][member.person_id].reasons.push(reason);
			} else if(criterion === '1.4') {
				qualified[type][member.country_code][member.person_id].reasons.push({criterion: criterion});
			} else {
				if(member.prequalified_uv) {
					var reason = {
						criterion: criterion,
						event: eventIds[member.event_id].slug,
						gender: member.gender,
						position: member.position_uv,
						age: 'ultraveteran'
					};
					qualified[type][member.country_code][member.person_id].reasons.push(reason);
				}
				if(member.prequalified_sv) {
					var reason = {
						criterion: criterion,
						event: eventIds[member.event_id].slug,
						gender: member.gender,
						position: member.position_sv,
						age: 'superveteran'
					};
					qualified[type][member.country_code][member.person_id].reasons.push(reason);
				}
				if(member.prequalified_v) {
					var reason = {
						criterion: criterion,
						event: eventIds[member.event_id].slug,
						gender: member.gender,
						position: member.position_v,
						age: 'veteran'
					};
					qualified[type][member.country_code][member.person_id].reasons.push(reason);
				}
				if(member.prequalified_o) {
					var reason = {
						criterion: criterion,
						event: eventIds[member.event_id].slug,
						gender: member.gender,
						position: member.position_o,
						age: 'open'
					};
					qualified[type][member.country_code][member.person_id].reasons.push(reason);
				}
				if(member.prequalified_j) {
					var reason = {
						criterion: criterion,
						event: eventIds[member.event_id].slug,
						gender: member.gender,
						position: member.position_j,
						age: 'junior'
					};
					qualified[type][member.country_code][member.person_id].reasons.push(reason);
				}
			}
		}
	}
}

function unaccent(text) {
	return text.replace(this.re, function(a){return this.replacemets[a]||a;});
}
unaccent.prototype = {
	replacemets: {'À': 'A', 'Á': 'A', 'Â': 'A', 'Ã': 'A', 'Ä': 'A', 'Å': 'A', 'Æ': 'A', 'à': 'a', 'á': 'a', 'â': 'a', 'ã': 'a', 'ä': 'a', 'å': 'a', 'æ': 'a', 'Ā': 'A', 'ā': 'a', 'Ă': 'A', 'ă': 'a', 'Ą': 'A', 'ą': 'a', 'Ç': 'C', 'ç': 'c', 'Ć': 'C', 'ć': 'c', 'Ĉ': 'C', 'ĉ': 'c', 'Ċ': 'C', 'ċ': 'c', 'Č': 'C', 'č': 'c', 'Ď': 'D', 'ď': 'd', 'Đ': 'D', 'đ': 'd', 'È': 'E', 'É': 'E', 'Ê': 'E', 'Ë': 'E', 'è': 'e', 'é': 'e', 'ê': 'e', 'ë': 'e', 'Ē': 'E', 'ē': 'e', 'Ĕ': 'E', 'ĕ': 'e', 'Ė': 'E', 'ė': 'e', 'Ę': 'E', 'ę': 'e', 'Ě': 'E', 'ě': 'e', 'Ĝ': 'G', 'ĝ': 'g', 'Ğ': 'G', 'ğ': 'g', 'Ġ': 'G', 'ġ': 'g', 'Ģ': 'G', 'ģ': 'g', 'Ĥ': 'H', 'ĥ': 'h', 'Ħ': 'H', 'ħ': 'h', 'Ĩ': 'I', 'Ì': 'I', 'Í': 'I', 'Î': 'I', 'Ï': 'I', 'ì': 'i', 'í': 'i', 'î': 'i', 'ï': 'i', 'ĩ': 'i', 'Ī': 'I', 'ī': 'i', 'Ĭ': 'I', 'ĭ': 'i', 'Į': 'I', 'į': 'i', 'İ': 'I', 'ı': 'i', 'Ĳ': 'I', 'ĳ': 'i', 'Ĵ': 'J', 'ĵ': 'j', 'Ķ': 'K', 'ķ': 'k', 'ĸ': 'k', 'Ĺ': 'L', 'ĺ': 'l', 'Ļ': 'L', 'ļ': 'l', 'Ľ': 'L', 'ľ': 'l', 'Ŀ': 'L', 'ŀ': 'l', 'Ł': 'L', 'ł': 'l', 'Ñ': 'N', 'ñ': 'n', 'Ń': 'N', 'ń': 'n', 'Ņ': 'N', 'ņ': 'n', 'Ň': 'N', 'ň': 'n', 'ŉ': 'n', 'Ŋ': 'N', 'ŋ': 'n', 'Ò': 'O', 'Ó': 'O', 'Ô': 'O', 'Õ': 'O', 'Ö': 'O', 'ò': 'o', 'ó': 'o', 'ô': 'o', 'õ': 'o', 'ö': 'o', 'Ō': 'O', 'ō': 'o', 'Ŏ': 'O', 'ŏ': 'o', 'Ő': 'O', 'ő': 'o', 'Œ': 'E', 'œ': 'e', 'Ø': 'O', 'ø': 'o', 'Ŕ': 'R', 'ŕ': 'r', 'Ŗ': 'R', 'ŗ': 'r', 'Ř': 'R', 'ř': 'r', 'ß': 'S', 'Ś': 'S', 'ś': 's', 'Ŝ': 'S', 'ŝ': 's', 'Ş': 'S', 'ş': 's', 'Š': 'S', 'š': 's', 'Ţ': 'T', 'ţ': 't', 'Ť': 'T', 'ť': 't', 'Ŧ': 'T', 'ŧ': 't', 'Ù': 'U', 'Ú': 'U', 'Û': 'U', 'Ü': 'U', 'ù': 'u', 'ú': 'u', 'û': 'u', 'ü': 'u', 'Ũ': 'U', 'ũ': 'u', 'Ū': 'U', 'ū': 'u', 'Ŭ': 'U', 'ŭ': 'u', 'Ů': 'U', 'ů': 'u', 'Ű': 'U', 'ű': 'u', 'Ų': 'U', 'ų': 'u', 'Ŵ': 'W', 'ŵ': 'w', 'Ý': 'Y', 'ý': 'y', 'ÿ': 'y', 'Ŷ': 'Y', 'ŷ': 'y', 'Ÿ': 'Y', 'Ź': 'Z', 'ź': 'z', 'Ż': 'Z', 'ż': 'z', 'Ž': 'Z', 'ž': 'z', 'ё': 'е', 'Ё': 'Е'},
	're': new RegExp('[^A-Za-z0-9\\[\\] ]', 'g')
};

function compare_member(a, b) {
	return unaccent((a.lastname + ' ' + a.firstname).toLowerCase()).localeCompare(unaccent((b.lastname + ' ' + b.firstname).toLowerCase()));
}

app.get('/qualified', function(req, res) {
	pg.connect(_dbUri, function(err, client, done) {
		var eventIds = {};
		var eventsQuery = client.query('select * from event', function(){});
		eventsQuery.on('row', function(row) {eventIds[row.id] = row;});
		await eventsQuery.on('end', defer());

		var qualified = {auto: {}, preferred: {}};

		// criterion 1.1
		await client.query(
			"with past_event as (select id from event where level = 'world'), past_team as (select *, count(*) over w as \"limit\", row_number() over (w order by score desc, time asc) as position from team where event_id in (select * from past_event) window w as (partition by event_id, gender)), recent_event as (select id from event where level = 'world' and \"end\" < current_date order by \"end\" desc limit 2), recent_event_attendee as (select person_id from member where (event_id, team_id) in (select event_id, id from team where event_id in (select * from recent_event))) select *, true as prequalified_o from member left join past_team on member.event_id = past_team.event_id and member.team_id = past_team.id where position = 1 and person_id in (select person_id from recent_event_attendee);",
			defer(var err, criterion_qualified)
		);
		if(err) {
			console.error(err);
		}
		pushQualified(qualified, 'auto', '1.1', criterion_qualified, eventIds);

		// criterion 1.2a
		await client.query(
			"with recent_event as (select id from event where level = 'world' and \"end\" < current_date and \"end\" > current_date - interval '3 years' order by \"end\" desc limit 2), past_team as (select *, 0.5 as coef, 6 as ceiling, position_in_class(age, 'ultraveteran') over (w order by score desc, time asc) as position_uv, count(nullif(is_in_class(age, 'ultraveteran'), false)) over w as limit_uv, position_in_class(age, 'superveteran') over (w order by score desc, time asc) as position_sv, count(nullif(is_in_class(age, 'superveteran'), false)) over w as limit_sv, position_in_class(age, 'veteran') over (w order by score desc, time asc) as position_v, count(nullif(is_in_class(age, 'veteran'), false)) over w as limit_v, position_in_class(age, 'open') over (w order by score desc, time asc) as position_o, count(nullif(is_in_class(age, 'open'), false)) over w as limit_o, position_in_class(age, 'junior') over (w order by score desc, time asc) as position_j, count(nullif(is_in_class(age, 'junior'), false)) over w as limit_j from team where event_id in (select * from recent_event) window w as (partition by event_id, gender)), past_team_crit as (select *, (position_uv <= ceiling and position_uv <= ceil(limit_uv*coef)) as prequalified_uv, (position_sv <= ceiling and position_sv <= ceil(limit_sv*coef)) as prequalified_sv, (position_v <= ceiling and position_v <= ceil(limit_v*coef)) as prequalified_v, (position_o <= ceiling and position_o <= ceil(limit_o*coef)) as prequalified_o, (position_j <= ceiling and position_j <= ceil(limit_j*coef)) as prequalified_j from past_team) select * from member left join past_team_crit on member.event_id = past_team_crit.event_id and member.team_id = past_team_crit.id where prequalified_uv or prequalified_sv or prequalified_v or prequalified_o or prequalified_j;",
			defer(var err, criterion_qualified)
		);
		if(err) {
			console.error(err);
		}
		pushQualified(qualified, 'auto', '1.2a', criterion_qualified, eventIds);

		// criterion 1.2b
		await client.query(
			"with recent_event as (select id from event where level = 'regional-e' and \"end\" < current_date and \"end\" > current_date - interval '3 years' order by \"end\" desc limit 2), past_team as (select *, 0.5 as coef, 3 as ceiling, position_in_class(age, 'ultraveteran') over (w order by score desc, time asc) as position_uv, count(nullif(is_in_class(age, 'ultraveteran'), false)) over w as limit_uv, position_in_class(age, 'superveteran') over (w order by score desc, time asc) as position_sv, count(nullif(is_in_class(age, 'superveteran'), false)) over w as limit_sv, position_in_class(age, 'veteran') over (w order by score desc, time asc) as position_v, count(nullif(is_in_class(age, 'veteran'), false)) over w as limit_v, position_in_class(age, 'open') over (w order by score desc, time asc) as position_o, count(nullif(is_in_class(age, 'open'), false)) over w as limit_o, position_in_class(age, 'junior') over (w order by score desc, time asc) as position_j, count(nullif(is_in_class(age, 'junior'), false)) over w as limit_j from team where event_id in (select * from recent_event) window w as (partition by event_id, gender)), past_team_crit as (select *, (position_uv <= ceiling and position_uv <= ceil(limit_uv*coef)) as prequalified_uv, (position_sv <= ceiling and position_sv <= ceil(limit_sv*coef)) as prequalified_sv, (position_v <= ceiling and position_v <= ceil(limit_v*coef)) as prequalified_v, (position_o <= ceiling and position_o <= ceil(limit_o*coef)) as prequalified_o, (position_j <= ceiling and position_j <= ceil(limit_j*coef)) as prequalified_j from past_team) select * from member left join past_team_crit on member.event_id = past_team_crit.event_id and member.team_id = past_team_crit.id where prequalified_uv or prequalified_sv or prequalified_v or prequalified_o or prequalified_j;",
			defer(var err, criterion_qualified)
		);
		if(err) {
			console.error(err);
		}
		pushQualified(qualified, 'auto', '1.2b', criterion_qualified, eventIds);

		// criterion 1.2c
		await client.query(
			"with recent_event as (select id from event where level = 'regional-na' and \"end\" < current_date and \"end\" > current_date - interval '3 years' order by \"end\" desc limit 2), past_team as (select *, 0.5 as coef, 2 as ceiling, position_in_class(age, 'ultraveteran') over (w order by score desc, time asc) as position_uv, count(nullif(is_in_class(age, 'ultraveteran'), false)) over w as limit_uv, position_in_class(age, 'superveteran') over (w order by score desc, time asc) as position_sv, count(nullif(is_in_class(age, 'superveteran'), false)) over w as limit_sv, position_in_class(age, 'veteran') over (w order by score desc, time asc) as position_v, count(nullif(is_in_class(age, 'veteran'), false)) over w as limit_v, position_in_class(age, 'open') over (w order by score desc, time asc) as position_o, count(nullif(is_in_class(age, 'open'), false)) over w as limit_o, position_in_class(age, 'junior') over (w order by score desc, time asc) as position_j, count(nullif(is_in_class(age, 'junior'), false)) over w as limit_j from team where event_id in (select * from recent_event) window w as (partition by event_id, gender)), past_team_crit as (select *, (position_uv <= ceiling and position_uv <= ceil(limit_uv*coef)) as prequalified_uv, (position_sv <= ceiling and position_sv <= ceil(limit_sv*coef)) as prequalified_sv, (position_v <= ceiling and position_v <= ceil(limit_v*coef)) as prequalified_v, (position_o <= ceiling and position_o <= ceil(limit_o*coef)) as prequalified_o, (position_j <= ceiling and position_j <= ceil(limit_j*coef)) as prequalified_j from past_team) select * from member left join past_team_crit on member.event_id = past_team_crit.event_id and member.team_id = past_team_crit.id where prequalified_uv or prequalified_sv or prequalified_v or prequalified_o or prequalified_j;",
			defer(var err, criterion_qualified)
		);
		if(err) {
			console.error(err);
		}
		pushQualified(qualified, 'auto', '1.2c', criterion_qualified, eventIds);

		// criterion 1.2d
		await client.query(
			"with recent_event as (select id from event where level = 'regional-a' and \"end\" < current_date and \"end\" > current_date - interval '3 years' order by \"end\" desc limit 2), past_team as (select *, 0.5 as coef, 2 as ceiling, position_in_class(age, 'ultraveteran') over (w order by score desc, time asc) as position_uv, count(nullif(is_in_class(age, 'ultraveteran'), false)) over w as limit_uv, position_in_class(age, 'superveteran') over (w order by score desc, time asc) as position_sv, count(nullif(is_in_class(age, 'superveteran'), false)) over w as limit_sv, position_in_class(age, 'veteran') over (w order by score desc, time asc) as position_v, count(nullif(is_in_class(age, 'veteran'), false)) over w as limit_v, position_in_class(age, 'open') over (w order by score desc, time asc) as position_o, count(nullif(is_in_class(age, 'open'), false)) over w as limit_o, position_in_class(age, 'junior') over (w order by score desc, time asc) as position_j, count(nullif(is_in_class(age, 'junior'), false)) over w as limit_j from team where event_id in (select * from recent_event) window w as (partition by event_id, gender)), past_team_crit as (select *, (position_uv <= ceiling and position_uv <= ceil(limit_uv*coef)) as prequalified_uv, (position_sv <= ceiling and position_sv <= ceil(limit_sv*coef)) as prequalified_sv, (position_v <= ceiling and position_v <= ceil(limit_v*coef)) as prequalified_v, (position_o <= ceiling and position_o <= ceil(limit_o*coef)) as prequalified_o, (position_j <= ceiling and position_j <= ceil(limit_j*coef)) as prequalified_j from past_team) select * from member left join past_team_crit on member.event_id = past_team_crit.event_id and member.team_id = past_team_crit.id where prequalified_uv or prequalified_sv or prequalified_v or prequalified_o or prequalified_j;",
			defer(var err, criterion_qualified)
		);
		if(err) {
			console.error(err);
		}
		pushQualified(qualified, 'auto', '1.2d', criterion_qualified, eventIds);

		// criterion 1.3
		await client.query(
			"with national as (select id, \"end\", row_number() over (partition by level order by \"end\" desc) as position from event where level in ('national-c', 'national-f', 'national-lv', 'national-r', 'national-nz', 'national-a', 'national-uk', 'national-us')), qualifying_national as (select id from national where \"end\" > current_date - interval '3 years' and position <= 2), past_team as (select *, 0.5 as coef, 2 as ceiling, count(*) over w as \"limit\", row_number() over (w order by score desc, time asc) as position from team where event_id in (select * from qualifying_national) window w as (partition by event_id, gender)), past_team_crit as (select *, (position <= ceiling and position <= ceil(\"limit\"*coef)) as prequalified_o from past_team) select * from member left join past_team_crit on member.event_id = past_team_crit.event_id and member.team_id = past_team_crit.id where prequalified_o;",
			defer(var err, criterion_qualified)
		);
		if(err) {
			console.error(err);
		}
		pushQualified(qualified, 'auto', '1.3', criterion_qualified, eventIds);

		// criterion 1.4
		await client.query(
			"select * from councillor;",
			defer(var err, criterion_qualified)
		);
		if(err) {
			console.error(err);
		}
		pushQualified(qualified, 'auto', '1.4', criterion_qualified);

		// criterion 2.1
		await client.query(
			"with recent_event as (select id from event where level = 'world' and \"end\" < current_date order by \"end\" desc limit 2), past_team as (select *, 0.3 as coef, 7 as floor, 10 as ceiling, position_in_class(age, 'ultraveteran') over (w order by score desc, time asc) as position_uv, count(nullif(is_in_class(age, 'ultraveteran'), false)) over w as limit_uv, position_in_class(age, 'superveteran') over (w order by score desc, time asc) as position_sv, count(nullif(is_in_class(age, 'superveteran'), false)) over w as limit_sv, position_in_class(age, 'veteran') over (w order by score desc, time asc) as position_v, count(nullif(is_in_class(age, 'veteran'), false)) over w as limit_v, position_in_class(age, 'open') over (w order by score desc, time asc) as position_o, count(nullif(is_in_class(age, 'open'), false)) over w as limit_o, position_in_class(age, 'junior') over (w order by score desc, time asc) as position_j, count(nullif(is_in_class(age, 'junior'), false)) over w as limit_j from team where event_id in (select * from recent_event) window w as (partition by event_id, gender)), past_team_crit as (select *, (position_uv >= floor and position_uv <= ceiling and position_uv <= ceil(limit_uv*coef)) as prequalified_uv, (position_sv >= floor and position_sv <= ceiling and position_sv <= ceil(limit_sv*coef)) as prequalified_sv, (position_v >= floor and position_v <= ceiling and position_v <= ceil(limit_v*coef)) as prequalified_v, (position_o >= floor and position_o <= ceiling and position_o <= ceil(limit_o*coef)) as prequalified_o, (position_j >= floor and position_j <= ceiling and position_j <= ceil(limit_j*coef)) as prequalified_j from past_team) select * from member left join past_team_crit on member.event_id = past_team_crit.event_id and member.team_id = past_team_crit.id where prequalified_uv or prequalified_sv or prequalified_v or prequalified_o or prequalified_j;",
			defer(var err, criterion_qualified)
		);
		if(err) {
			console.error(err);
		}
		pushQualified(qualified, 'preferred', '2.1', criterion_qualified, eventIds);

		// criterion 2.2
		await client.query(
			"with recent_event as (select id from event where level = 'regional-e' and \"end\" < current_date and \"end\" > current_date - interval '3 years' order by \"end\" desc limit 2), past_team as (select *, 0.3 as coef, 4 as floor, 5 as ceiling, position_in_class(age, 'ultraveteran') over (w order by score desc, time asc) as position_uv, count(nullif(is_in_class(age, 'ultraveteran'), false)) over w as limit_uv, position_in_class(age, 'superveteran') over (w order by score desc, time asc) as position_sv, count(nullif(is_in_class(age, 'superveteran'), false)) over w as limit_sv, position_in_class(age, 'veteran') over (w order by score desc, time asc) as position_v, count(nullif(is_in_class(age, 'veteran'), false)) over w as limit_v, position_in_class(age, 'open') over (w order by score desc, time asc) as position_o, count(nullif(is_in_class(age, 'open'), false)) over w as limit_o, position_in_class(age, 'junior') over (w order by score desc, time asc) as position_j, count(nullif(is_in_class(age, 'junior'), false)) over w as limit_j from team where event_id in (select * from recent_event) window w as (partition by event_id, gender)), past_team_crit as (select *, (position_uv >= floor and position_uv <= ceiling and position_uv <= ceil(limit_uv*coef)) as prequalified_uv, (position_sv >= floor and position_sv <= ceiling and position_sv <= ceil(limit_sv*coef)) as prequalified_sv, (position_v >= floor and position_v <= ceiling and position_v <= ceil(limit_v*coef)) as prequalified_v, (position_o >= floor and position_o <= ceiling and position_o <= ceil(limit_o*coef)) as prequalified_o, (position_j >= floor and position_j <= ceiling and position_j <= ceil(limit_j*coef)) as prequalified_j from past_team) select * from member left join past_team_crit on member.event_id = past_team_crit.event_id and member.team_id = past_team_crit.id where prequalified_uv or prequalified_sv or prequalified_v or prequalified_o or prequalified_j;",
			defer(var err, criterion_qualified)
		);
		if(err) {
			console.error(err);
		}
		pushQualified(qualified, 'preferred', '2.2', criterion_qualified, eventIds);

		// criterion 2.3a
		await client.query(
			"with recent_event as (select id from event where level = 'regional-na' and \"end\" < current_date and \"end\" > current_date - interval '3 years' order by \"end\" desc limit 2), past_team as (select *, 0.3 as coef, 3 as ceiling, 3 as floor, position_in_class(age, 'ultraveteran') over (w order by score desc, time asc) as position_uv, count(nullif(is_in_class(age, 'ultraveteran'), false)) over w as limit_uv, position_in_class(age, 'superveteran') over (w order by score desc, time asc) as position_sv, count(nullif(is_in_class(age, 'superveteran'), false)) over w as limit_sv, position_in_class(age, 'veteran') over (w order by score desc, time asc) as position_v, count(nullif(is_in_class(age, 'veteran'), false)) over w as limit_v, position_in_class(age, 'open') over (w order by score desc, time asc) as position_o, count(nullif(is_in_class(age, 'open'), false)) over w as limit_o, position_in_class(age, 'junior') over (w order by score desc, time asc) as position_j, count(nullif(is_in_class(age, 'junior'), false)) over w as limit_j from team where event_id in (select * from recent_event) window w as (partition by event_id, gender)), past_team_crit as (select *, (position_uv = ceiling and position_uv <= ceil(limit_uv*coef)) as prequalified_uv, (position_sv = ceiling and position_sv <= ceil(limit_sv*coef)) as prequalified_sv, (position_v = ceiling and position_v <= ceil(limit_v*coef)) as prequalified_v, (position_o = ceiling and position_o <= ceil(limit_o*coef)) as prequalified_o, (position_j = ceiling and position_j <= ceil(limit_j*coef)) as prequalified_j from past_team) select * from member left join past_team_crit on member.event_id = past_team_crit.event_id and member.team_id = past_team_crit.id where prequalified_uv or prequalified_sv or prequalified_v or prequalified_o or prequalified_j;",
			defer(var err, criterion_qualified)
		);
		if(err) {
			console.error(err);
		}
		pushQualified(qualified, 'preferred', '2.3a', criterion_qualified, eventIds);

		// criterion 2.3b
		await client.query(
			"with recent_event as (select id from event where level = 'regional-a' and \"end\" < current_date and \"end\" > current_date - interval '3 years' order by \"end\" desc limit 2), past_team as (select *, 1 as coef, 3 as ceiling, 3 as floor, position_in_class(age, 'ultraveteran') over (w order by score desc, time asc) as position_uv, count(nullif(is_in_class(age, 'ultraveteran'), false)) over w as limit_uv, position_in_class(age, 'superveteran') over (w order by score desc, time asc) as position_sv, count(nullif(is_in_class(age, 'superveteran'), false)) over w as limit_sv, position_in_class(age, 'veteran') over (w order by score desc, time asc) as position_v, count(nullif(is_in_class(age, 'veteran'), false)) over w as limit_v, position_in_class(age, 'open') over (w order by score desc, time asc) as position_o, count(nullif(is_in_class(age, 'open'), false)) over w as limit_o, position_in_class(age, 'junior') over (w order by score desc, time asc) as position_j, count(nullif(is_in_class(age, 'junior'), false)) over w as limit_j from team where event_id in (select * from recent_event) window w as (partition by event_id, gender)), past_team_crit as (select *, (position_uv = ceiling and position_uv <= ceil(limit_uv*coef)) as prequalified_uv, (position_sv = ceiling and position_sv <= ceil(limit_sv*coef)) as prequalified_sv, (position_v = ceiling and position_v <= ceil(limit_v*coef)) as prequalified_v, (position_o = ceiling and position_o <= ceil(limit_o*coef)) as prequalified_o, (position_j = ceiling and position_j <= ceil(limit_j*coef)) as prequalified_j from past_team) select * from member left join past_team_crit on member.event_id = past_team_crit.event_id and member.team_id = past_team_crit.id where prequalified_uv or prequalified_sv or prequalified_v or prequalified_o or prequalified_j;",
			defer(var err, criterion_qualified)
		);
		if(err) {
			console.error(err);
		}
		pushQualified(qualified, 'preferred', '2.3b', criterion_qualified, eventIds);

		var types = ['auto', 'preferred'];
		for(var type in types) {
			var type = types[type];
			var countries = Object.keys(qualified[type]).sort();
			var temporary = {};
			for(var country in countries) {
				if(countries.hasOwnProperty(country)) {
					var country = countries[country];
					var persons = [];
					for(var person in qualified[type][country]) {
						if(qualified[type][country].hasOwnProperty(person)) {
							persons.push(qualified[type][country][person]);
						}
					}
					persons.sort(compare_member);
					temporary[country] = persons;
				}
			}
			qualified[type] = temporary;
		}

		done();
		res.render('qualified', {title: 'List of pre-qualifying entrants', qualified: qualified, identity: req.user});
	});
});

function addMembers(members, row) {
	row.members = [];
	// var mcache = [];
	for(var i = 0; i < members.length; i++) {
		if(members[i].team_id == row.id) {
			row.members.push(members[i]);
			// mcache.push(i);
		}
	};
	// for(var i = mcache.length - 1; i >= 0; i--) {
	// 	members.splice(mcache[i], 1);
	// };
	// mcache = [];
}

app.get('/events/:event/results', function(req, res) {
	pg.connect(_dbUri, function(err, client, done) {
		await client.query('select * from event where slug=$1 limit 1', [req.params.event], defer(var row, eventdata));
		if(eventdata.rows.length == 0) {
			done();
			res.status(404);
			res.render('error/404', {body: 'Sorry, this event is not in our database, we may be working on it.'});
			return;
		}
		var event = eventdata.rows[0];
		if(!event.complete) {
			done();
			res.status(404);
			res.render('error/404', {body: 'Sorry, this event has no results (yet). We are working on it in this very moment.'});
			return;
		}

		await client.query('select * from member where event_id=$1', [event.id], defer(var row, members));
		members = members.rows;
		var openCategories = helpers.getCategoryDescendants('open').join('\',\'');
		var moquery = client.query('select * from team where event_id=$1 and gender=$2 and age in (\''+openCategories+'\') order by status=\'finished\' desc, score desc, time asc limit 3', [event.id, 'men'], function() {});
		moquery.on('row', function(row) {addMembers(members, row);});
		await moquery.on('end', defer(var mo));
		var xoquery = client.query('select * from team where event_id=$1 and gender=$2 and age in (\''+openCategories+'\') order by status=\'finished\' desc, score desc, time asc limit 3', [event.id, 'mixed'], function() {});
		xoquery.on('row', function(row) {addMembers(members, row);});
		await xoquery.on('end', defer(var xo));
		var woquery = client.query('select * from team where event_id=$1 and gender=$2 and age in (\''+openCategories+'\') order by status=\'finished\' desc, score desc, time asc limit 3', [event.id, 'women'], function() {});
		woquery.on('row', function(row) {addMembers(members, row);});
		await woquery.on('end', defer(var wo));
		
		var counters = {};
		var durations = [];
		var categories = [];
		var usedCategories = [];

		var defaultDuration = 24;

		var teamquery = client.query('select * from team where event_id=$1 order by status=\'finished\' desc, score desc, time asc', [event.id]);
		teamquery.on('row', function(row) {addMembers(members, row);});
		teamquery.on('row', function(row, result) {
			var gender = helpers.genderclass(row.gender);
			var age = helpers.ageclass(row.age);
			row.category = gender+age;

			if(durations.indexOf(row.duration) < 0) {
				durations.push(row.duration);
			}
			if(categories.indexOf(row.category) < 0) {
				categories.push(row.category);
			}

			var countToCategories = helpers.getCategoryParents(row.age, row.gender);
			for(var i = 0; i < countToCategories.length; i++) {
				var countToCategory = countToCategories[i];
				row[countToCategory] = increment(counters, row.duration, countToCategory);
			}
			row['place'] = increment(counters, row.duration, 'all');

			if(req.query.category) {
				var categoryDescendants = helpers.getCategoryDescendants(helpers.categoriesToObject[req.query.category].age, helpers.categoriesToObject[req.query.category].gender);
				var availableCategories = categoryDescendants.slice();
				Array.prototype.push.apply(availableCategories, helpers.getCategoryParents(helpers.categoriesToObject[req.query.category].age, helpers.categoriesToObject[req.query.category].gender));
				var currentCategoryIsActive = (categoryDescendants.indexOf(row.category) > -1);
			} else {
				var currentCategoryIsActive = true;
			}
			var currentDurationIsDefault = (!req.query.duration && defaultDuration === row.duration);
			var currentDurationIsActive = (parseInt(req.query.duration) === row.duration);
			if((!req.query.category || currentCategoryIsActive) && (currentDurationIsDefault || currentDurationIsActive)) {
				result.addRow(row);
				if (usedCategories.indexOf(row.category) < 0) {
					usedCategories.push(row.category);
				}
			}
		});
		await teamquery.on('end', defer(var teams));
		done();
		if(teams.rowCount == 0) {
			res.status(404);
			res.render('error/404', {body: 'Sorry, this event has no results (yet). We are working on it in this very moment.'});
			return;
		}

		var activeCategory = null;
		var activeDuration = null;
		var isCategoryInvalid = (req.query.hasOwnProperty('category') && categories.indexOf(req.query.category) < 0);
		var isDurationInvalid = (req.query.hasOwnProperty('duration') && durations.indexOf(parseInt(req.query.duration)) < 0);
		var isCategoryDefault = (req.query.hasOwnProperty('category') && req.query.category === '');
		var isDurationDefault = (req.query.hasOwnProperty('duration') && parseInt(req.query.duration) === defaultDuration);

		var displayedCategories = {};
		usedCategories.forEach(function(cat) {
			cat = helpers.decodeCategory(cat);
			var parents = helpers.getCategoryParents(cat.age, cat.gender);
			parents.forEach(function(parent) {
				if (!displayedCategories.hasOwnProperty(parent)) {
					displayedCategories[parent] = 1;
				}
			});
		});

		var allCategories = [];
		categories.forEach(function(cat) {
			cat = helpers.decodeCategory(cat);
			var parents = helpers.getCategoryParents(cat.age, cat.gender);
			parents.forEach(function(parent) {
				if (allCategories.indexOf(parent) < 0) {
					allCategories.push(parent);
				}
			});
		});

		var query = {};
		if(isCategoryDefault || isDurationDefault) {
			if(req.query.hasOwnProperty('duration') && !isDurationDefault) {
				query.duration = req.query.duration;
			}
			if(req.query.hasOwnProperty('category') && !isCategoryDefault) {
				query.category = req.query.category;
			}
			res.redirect(url.format({pathname: req._parsedUrl.pathname, query: query}));
			return;
		}
		if(isDurationInvalid || isCategoryInvalid) {
			res.status(404);
			res.render('error/404');
			return;
		}

		var activeDuration = req.query.hasOwnProperty('duration') ? parseInt(req.query.duration) : defaultDuration;
		res.render('results', {
			title: 'Results of ' + event.name,
			event: event,
			teams: teams.rows,
			mo: {teams: mo.rows},
			xo: {teams: xo.rows},
			wo: {teams: wo.rows},
			identity: req.user,
			is: displayedCategories,
			activeCategory: req.query.hasOwnProperty('category') && req.query.category != '' ? req.query.category : null,
			categories: allCategories.sort(function(a, b) {
				if (a[0] === b[0]) {
					var aAge = helpers.ageclassReverse[a.substr(1)];
					var bAge = helpers.ageclassReverse[b.substr(1)];

					if (aAge === bAge) {
						return 0;
					} else if (helpers.categorySorting[aAge].indexOf(bAge) < 0) {
						return 1;
					} else {
						return -1;
					}
				} else {
					return a[0] < b[0] ? -1 : 1;
				}
			}),
			counters: JSON.stringify(counters),
			activeDuration: activeDuration,
			durations: durations.length > 1 ? durations : null
		});
	});
});

app.get('/login', function(req, res) {
	res.render('login', {identity: req.user, values: req.body});
});

app.post('/login', passport.authenticate('local', {successRedirect: '/', failureFlash: true, failWithError: true}), function(err, req, res, next) {
	console.log(err);
	return res.render('login', {identity: req.user, values: req.body});
});

app.get('/logout', function(req, res) {
	req.logout();
	res.redirect('/');
});

app.listen(app.get('port'), function() {
	console.log('Started app on port %d', app.get('port'));
});
